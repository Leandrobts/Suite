// js/core_exploit.mjs
import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs'; // Usando utils.mjs
import { logS3 as log } from './script3/s3_utils.mjs'; // Assumindo que logS3 é o logger padrão para este módulo
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from '../config.mjs'; // Ajuste o caminho se config.mjs estiver em js/

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

// Helper para o toHexS1 que estava no core_exploit original, agora usa o toHex de utils.mjs
const toHexHelper = (val, bits = 32) => toHex(val, bits);


export function clearOOBEnvironment() {
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment';
    log(`Limpando ambiente OOB...`, 'info', FNAME_CLEAR);
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    log(`Ambiente OOB limpo.`, 'good', FNAME_CLEAR);
}

export function getOOBAllocationSize() { updateOOBConfigFromUI(document); return OOB_CONFIG.ALLOCATION_SIZE; }
export function getBaseOffsetInDV() { updateOOBConfigFromUI(document); return OOB_CONFIG.BASE_OFFSET_IN_DV; }
export function getInitialBufferSize() { updateOOBConfigFromUI(document); return OOB_CONFIG.INITIAL_BUFFER_SIZE; }

export async function triggerOOB_primitive() {
    const FNAME = 'CoreExploit.triggerOOB_primitive';
    updateOOBConfigFromUI(document); // Passando document explicitamente
    log(`--- Iniciando ${FNAME} ---`, 'test', FNAME);
    log(`   Config OOB: AllocSize=${OOB_CONFIG.ALLOCATION_SIZE}, BaseOffsetDV=${OOB_CONFIG.BASE_OFFSET_IN_DV}, InitialBufSize=${OOB_CONFIG.INITIAL_BUFFER_SIZE}`, 'info', FNAME);
    clearOOBEnvironment();
    try {
        if (OOB_CONFIG.ALLOCATION_SIZE <= 0) throw new Error(`Tamanho de Alocação OOB inválido: ${OOB_CONFIG.ALLOCATION_SIZE}.`);
        // Ajuste para garantir que BASE_OFFSET_IN_DV + ALLOCATION_SIZE não exceda o tamanho total.
        // O totalSizeNeeded deve ser o tamanho do oob_array_buffer_real.
        // oob_dataview_real é uma janela dentro dele.
        // A janela é [BASE_OFFSET_IN_DV, BASE_OFFSET_IN_DV + ALLOCATION_SIZE - 1]
        const totalSizeForArrayBuffer = OOB_CONFIG.BASE_OFFSET_IN_DV + OOB_CONFIG.ALLOCATION_SIZE + 128; // Adiciona um buffer extra para segurança
        if (totalSizeForArrayBuffer <=0 ) throw new Error(`Cálculo de tamanho total inválido: ${totalSizeForArrayBuffer}.`);
        
        oob_array_buffer_real = new ArrayBuffer(totalSizeForArrayBuffer);
        // Garante que a DataView não exceda o ArrayBuffer
        if (OOB_CONFIG.BASE_OFFSET_IN_DV + OOB_CONFIG.ALLOCATION_SIZE > totalSizeForArrayBuffer) {
            throw new Error(`DataView excede ArrayBuffer: offset+length=${OOB_CONFIG.BASE_OFFSET_IN_DV + OOB_CONFIG.ALLOCATION_SIZE}, total=${totalSizeForArrayBuffer}`);
        }
        oob_dataview_real = new DataView(oob_array_buffer_real, OOB_CONFIG.BASE_OFFSET_IN_DV, OOB_CONFIG.ALLOCATION_SIZE);
        
        log(`Ambiente para Operações OOB CONFIGURADO.`, 'vuln', FNAME);
        log(`   oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME);
        log(`   oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.byteLength} bytes`, 'info', FNAME);
    } catch (e) {
        log(`ERRO CRÍTICO ao tentar configurar ambiente OOB: ${e.name} - ${e.message}`, "error", FNAME);
        console.error("Erro detalhado em triggerOOB_primitive:", e);
        oob_array_buffer_real = null; oob_dataview_real = null;
    }
    log(`--- ${FNAME} Concluído ---`, 'test', FNAME);
}

// Offsets são relativos ao início do oob_array_buffer_real
export function oob_read_absolute(absolute_offset, byteLength = 4) {
    if (!oob_array_buffer_real) {
        log("ERRO: oob_array_buffer_real não ativo para leitura.", "error", "CoreExploit.ReadAbs");
        throw new Error("OOB Read Abs: Ambiente não ativo.");
    }
    if (absolute_offset < 0 || absolute_offset + byteLength > oob_array_buffer_real.byteLength) {
        log(`ERRO Leitura OOB Abs: Offset ${toHexHelper(absolute_offset)} FORA dos limites (${oob_array_buffer_real.byteLength}b).`, "error", "CoreExploit.ReadAbs");
        throw new RangeError(`OOB Read Abs: Fora dos limites. Offset: ${absolute_offset}, Len: ${byteLength}, BufSize: ${oob_array_buffer_real.byteLength}`);
    }
    const tempView = new DataView(oob_array_buffer_real);
    try {
        if (byteLength === 1) return tempView.getUint8(absolute_offset);
        if (byteLength === 2) return tempView.getUint16(absolute_offset, true);
        if (byteLength === 4) return tempView.getUint32(absolute_offset, true);
        if (byteLength === 8) {
            const low = tempView.getUint32(absolute_offset, true);
            const high = tempView.getUint32(absolute_offset + 4, true);
            return new AdvancedInt64(low, high);
        }
        throw new Error("Tamanho de leitura OOB (abs) inválido: " + byteLength);
    } catch (e) {
        log(`Exceção durante oob_read_absolute em offset ${toHexHelper(absolute_offset)}: ${e.name} - ${e.message}`, "error", "CoreExploit.ReadAbs");
        throw e;
    }
}

// Offsets são relativos ao início do oob_array_buffer_real
export function oob_write_absolute(absolute_offset, value, byteLength = 4) {
    if (!oob_array_buffer_real) {
        log("ERRO: oob_array_buffer_real não ativo para escrita.", "error", "CoreExploit.WriteAbs");
        throw new Error("OOB Write Abs: Ambiente não ativo.");
    }
    if (absolute_offset < 0 || absolute_offset + byteLength > oob_array_buffer_real.byteLength) {
        log(`ERRO Escrita OOB Abs: Offset ${toHexHelper(absolute_offset)} FORA dos limites (${oob_array_buffer_real.byteLength}b).`, "error", "CoreExploit.WriteAbs");
        throw new RangeError(`OOB Write Abs: Fora dos limites. Offset: ${absolute_offset}, Len: ${byteLength}, BufSize: ${oob_array_buffer_real.byteLength}`);
    }
    const tempView = new DataView(oob_array_buffer_real);
    try {
        if (byteLength === 1) { tempView.setUint8(absolute_offset, Number(value)); return; }
        if (byteLength === 2) { tempView.setUint16(absolute_offset, Number(value), true); return; }
        if (byteLength === 4) { tempView.setUint32(absolute_offset, Number(value), true); return; }
        if (byteLength === 8) {
            let valToSet = value;
            if (typeof value === 'number') {
                valToSet = AdvancedInt64.fromNumber(value); // Converte se for número JS
            }
            if (!isAdvancedInt64Object(valToSet)) {
                throw new TypeError("Para escrita OOB 8-byte, o valor deve ser um AdvancedInt64 ou um número JS válido.");
            }
            tempView.setUint32(absolute_offset, valToSet.low(), true);
            tempView.setUint32(absolute_offset + 4, valToSet.high(), true);
            return;
        }
        throw new Error("Tamanho/valor de escrita OOB (abs) inválido: " + byteLength + ", valor: " + String(value));
    } catch (e) {
        log(`Exceção durante oob_write_absolute em offset ${toHexHelper(absolute_offset)}: ${e.name} - ${e.message}`, "error", "CoreExploit.WriteAbs");
        throw e;
    }
}


// As funções oob_read_relative e oob_write_relative podem ser mantidas se a lógica de offset for útil,
// mas para um teste especulativo que não sabe onde as coisas estão, offsets absolutos dentro do
// oob_array_buffer_real podem ser mais diretos para "tentar a sorte".
// Se você mantiver as funções relativas, certifique-se de que o cálculo do offset é o que você espera.
// O log de debug no seu core_exploit.mjs para read8 usava `_isAdvancedInt64Prop`, que não existe mais.
// `isAdvancedInt64Object(int64Instance)` deve ser usado.

export async function testCoreExploitModule(logFnParam) { // Renomeado de testModule para clareza
    const FNAME_TEST = "CoreExploit.testModule";
    const currentLog = logFnParam || log; // Usa logS3 por padrão se logFnParam não for passado
    
    currentLog(`--- Testando Módulo CoreExploit (core_exploit.mjs) ---`, "test", FNAME_TEST);
    await triggerOOB_primitive(); 
    if (!oob_array_buffer_real) {
        currentLog("Falha ao configurar ambiente OOB. Teste do módulo abortado.", "error", FNAME_TEST);
        return;
    }
    
    // Teste com offsets absolutos dentro de oob_array_buffer_real
    // Os primeiros bytes de oob_array_buffer_real podem ser metadados do DataView ou do próprio ArrayBuffer
    // se eles estiverem dentro da mesma alocação, o que é dependente da implementação do motor JS.
    // Vamos testar a escrita em uma área segura dentro do buffer.
    const safe_abs_offset = OOB_CONFIG.BASE_OFFSET_IN_DV + Math.floor(OOB_CONFIG.ALLOCATION_SIZE / 2); // Meio da janela DataView
    const test_val32 = 0x12345678;
    const test_val64 = new AdvancedInt64("0xAABBCCDDEEFF0011");

    try {
        currentLog(`Escrevendo ${toHexHelper(test_val32)} em offset absoluto ${toHexHelper(safe_abs_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(safe_abs_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(safe_abs_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_abs_offset = safe_abs_offset + 4;
        currentLog(`Escrevendo ${test_val64.toString(true)} em offset absoluto ${toHexHelper(next_abs_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(next_abs_offset, test_val64, 8);
        const read_val64 = oob_read_absolute(next_abs_offset, 8);
        
        if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            const readValStr = isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64);
            currentLog(`FALHA: Lido ${readValStr}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST);
        }
    } catch (e) {
        currentLog(`ERRO durante o teste do módulo CoreExploit: ${e.name} - ${e.message}`, "error", FNAME_TEST);
        console.error("Erro em CoreExploit.testModule:", e);
    }
    currentLog(`--- Teste CoreExploit Concluído ---`, "test", FNAME_TEST);
}
